name: PR Auto Merge

on:
  issue_comment:
    types: [created]
  pull_request_review:
    types: [submitted]
  pull_request:
    types: [labeled]
  status: {}
  check_suite:
    types: [completed]

jobs:
  handle-commands:
    if: github.event.issue.pull_request && (contains(github.event.comment.body, '/lgtm') || contains(github.event.comment.body, '/approve'))
    runs-on: ubuntu-latest
    permissions:
      contents: read
      issues: write
      pull-requests: write
      
    steps:
    - name: Handle comment commands
      uses: actions/github-script@v7
      with:
        script: |
          const comment = context.payload.comment.body.toLowerCase();
          const commenter = context.payload.comment.user.login;
          const prNumber = context.issue.number;
          
          // Check if user is a collaborator
          const { data: collaborators } = await github.rest.repos.listCollaborators({
            owner: context.repo.owner,
            repo: context.repo.repo
          });
          
          const isCollaborator = collaborators.some(c => c.login === commenter);
          
          if (!isCollaborator) {
            console.log(`${commenter} is not a collaborator, ignoring command`);
            return;
          }
          
          const labelsToAdd = [];
          
          if (comment.includes('/lgtm')) {
            labelsToAdd.push('lgtm');
          }
          
          if (comment.includes('/approve')) {
            labelsToAdd.push('approved');
          }
          
          if (labelsToAdd.length > 0) {
            // Create labels if they don't exist
            for (const labelName of labelsToAdd) {
              try {
                await github.rest.issues.getLabel({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  name: labelName
                });
              } catch (error) {
                if (error.status === 404) {
                  await github.rest.issues.createLabel({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    name: labelName,
                    color: '0e8a16',
                    description: `Added by ${labelName} command`
                  });
                }
              }
            }
            
            await github.rest.issues.addLabels({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prNumber,
              labels: labelsToAdd
            });
            
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prNumber,
              body: `Added labels: ${labelsToAdd.join(', ')} by @${commenter}`
            });
          }
  
  auto-merge:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
    steps:
    - name: Auto merge PR
      uses: actions/github-script@v7
      with:
        script: |
          // Get all open PRs with both labels
          const { data: prs } = await github.rest.pulls.list({
            owner: context.repo.owner,
            repo: context.repo.repo,
            state: 'open'
          });
          
          for (const pr of prs) {
            const { data: labels } = await github.rest.issues.listLabelsOnIssue({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: pr.number
            });
            
            const hasLgtm = labels.some(label => label.name === 'lgtm');
            const hasApproved = labels.some(label => label.name === 'approved');
            
            if (hasLgtm && hasApproved && pr.mergeable && !pr.draft) {
              // Check status checks
              const { data: statusChecks } = await github.rest.repos.getCombinedStatusForRef({
                owner: context.repo.owner,
                repo: context.repo.repo,
                ref: pr.head.sha
              });
              
              const { data: checkRuns } = await github.rest.checks.listForRef({
                owner: context.repo.owner,
                repo: context.repo.repo,
                ref: pr.head.sha
              });
              
              const allStatusesPass = statusChecks.state === 'success' || statusChecks.statuses.length === 0;
              const allChecksPass = checkRuns.check_runs.every(check => 
                check.conclusion === 'success' || check.conclusion === 'neutral' || check.conclusion === 'skipped'
              );
              
              if (allStatusesPass && allChecksPass) {
                try {
                  await github.rest.pulls.merge({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    pull_number: pr.number,
                    commit_title: `${pr.title} (#${pr.number})`,
                    merge_method: 'squash'
                  });
                  
                  console.log(`Successfully merged PR #${pr.number}`);
                } catch (error) {
                  console.log(`Failed to merge PR #${pr.number}: ${error.message}`);
                }
              }
            }
          }